/* SPDX-License-Identifier: LGPL-3.0-or-later */

#include <reg.h>

#include <stdlib.h>
#include <string.h>
#include <assert.h>

/* reg_gperf.h is generated by gperf */
#include <reg_gperf.h>

static char* x_strchr(const char *s, int c) {
	char* n = NULL;

	if ((n = strchr(s, c))) {
		*(n++) = '\0';
		return n;
	}

	return n;
}

static int reg_from_pair(struct reg* reg, char* key, unsigned long int value) {
	assert(value < 0xFFFF);

	/* in_word_set() is generated by gperf */
	struct reg_decode* rd = in_word_set(key, strlen(key));
	if (!rd) {
		return -1;
	}

	reg->addr[rd->reg_name] = value;

	return 0;
}

static int reg_from_line(struct reg* reg, char* line) {
	const char sep[] = " ";
	char* key = line;
	char* value = NULL;

	if (line[0] == '\0' || line[0] == '#')
		return 0;

	if (!(value = strchr(line, '=')))
		return -1;
	*(value++) = '\0';

	key = strtok(key, sep);
	assert(key);

	reg_from_pair(reg, key, strtoul(value, NULL, 16));

	return 0;
}

static int reg_validate(struct reg* reg) {
	size_t i = 0;

	for (i = 0; i < REG_MAX; ++i) {
		if (reg->addr[i] == 0xffff) {
			reg->error_str = "Missed register address";
			return -1;
		}
	}

	return 0;
}

static int reg_init_from_map(struct reg* reg, char* map) {
	char* c = map;
	char* n = NULL;

	do {
		n = x_strchr(c, '\n');
		if (reg_from_line(reg, c)) {
			reg->error_str = "Can not parse register map";

			return -1;
		}
		c = n;
	} while (n);

	return reg_validate(reg);
}

int reg_init(struct reg* reg, char* map) {
	memset(reg, 0xff, sizeof(struct reg));
	reg->error_str = NULL;

	return reg_init_from_map(reg, map);
}

int reg_init_from_fwpkg(struct reg* reg, struct fwpkg* fwpkg) {
	size_t size = 0;
	char* tmp = NULL;
	int ret = 0;

	size = fwpkg_map_size(fwpkg)+1;
	tmp = malloc(size);
	if (!tmp) {
		reg->error_str = "Cannot allocate memory for register map";
		goto fail_malloc;
	}

	ret = fwpkg_read_map(fwpkg, tmp, &size);
	if (ret < 0) {
		reg->error_str = fwpkg_get_error_string(fwpkg);
		goto fail_fwpkg_read_map;
	}
	tmp[size] = '\0';

	ret = reg_init(reg, tmp);
	if (ret < 0) {
		goto fail_reg_init;
	}

	free(tmp);
	tmp = NULL;

	return 0;

fail_reg_init:
fail_fwpkg_read_map:
	if (tmp) {
		free(tmp);
	}
fail_malloc:

	return -1;
}

int reg_init_from_reg(struct reg* reg, struct reg* other) {
	memmove(reg, other, sizeof(struct reg));

	return 0;
}

const char* reg_get_error_string(struct reg* reg) {
	return reg->error_str;
}
